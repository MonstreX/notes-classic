ТЗ для AI Code Reviewer
Контекст: Локальное Tauri-приложение, Vanilla TS (без фреймворков), слоистая архитектура (UI -> Controller -> Service -> Backend).

1. Соблюдение границ слоев (Architectural Integrity)
UI Layer: Проверять, чтобы модули в src/ui/ не вызывали напрямую invoke или БД. Весь ввод должен идти через интерфейсы обработчиков в Controller.

Controller: Убедиться, что appController.ts не манипулирует DOM напрямую, а только обновляет store.

IPC: Проверять, что все вызовы к Backend проходят строго через src/services/.

2. Управление памятью и DOM (Vanilla TS)
Event Listeners: Искать потенциальные утечки памяти. При каждом перерендере или смене ноты старые обработчики событий должны удаляться.

State Updates: Проверять эффективность «shallow merges» в store.ts. Избегать лишних уведомлений подписчиков, если данные не изменились. Важно: Set/Map должны обновляться иммутабельно (новыми экземплярами). appStore.update уже клонирует Set/Map, а setState — нет, поэтому при setState нельзя мутировать текущие коллекции.

3. Целостность контента (Content Pipeline)
Protocol Mapping: Строго проверять корректность преобразования ссылок files/ в Asset URLs при загрузке (toDisplayContent) и обратно при сохранении (toStorageContent).

Editor Blocks: Следить за сохранностью структуры кастомных блоков (div.note-callout, div.note-secure, div.note-code). Любая деструктивная модификация HTML-схемы должна блокироваться.

4. Безопасность и Backend (Rust/SQLite)
Crypto: Проверять использование WebCrypto (AES-GCM) в crypto.ts. Пароли не должны кешироваться в открытом виде.

SQL Queries: Искать неоптимизированные выборки в db.rs. Все поисковые запросы должны использовать FTS5 индексы (notes_fts, ocr_fts).

Error Handling: Каждая команда в main.rs должна возвращать Result<T, String> и корректно обрабатываться на стороне TS через logError.

5. Производительность (Performance)
Debounce: Проверять наличие дебаунса для автосохранения (1000ms) и записи настроек (200ms).

OCR Queue: Убедиться, что OCR-задачи не блокируют основной поток и имеют лимит попыток (attempts_left).


Вот список общих критериев для проверки:

1. SRP (Single Responsibility Principle) — Принцип единственной ответственности
Соблюдение границ слоев: Каждый модуль должен заниматься только своей задачей: UI — отрисовкой, Service — транспортом данных (IPC), Controller — логикой.

Изоляция логики: Проверять, чтобы appController.ts не разрастался до «всемогущего объекта» и не содержал специфичных деталей реализации работы с БД или DOM.

2. KIS (Keep It Simple) — Простота реализации
Vanilla DOM: Избегать сложных абстракций там, где достаточно стандартных методов DOM, учитывая отказ от React.

Читаемость: Названия функций и переменных должны четко отражать их роль в бизнес-логике (например, toStorageContent вместо простого save).

3. DRY (Don't Repeat Yourself) — Избегание дублирования
Общие сервисы: Весь доступ к Rust-командам должен быть централизован в src/services/. Дублирование вызовов invoke в UI-компонентах недопустимо.

Утилиты контента: Использовать единые функции нормализации контента (normalizeEnmlContent, ensureNotesScheme) для предотвращения разной интерпретации данных в редакторе и при поиске.

4. Reliability (Надежность)
Обработка ошибок: Проверять наличие Result в Rust и соответствующих блоков try-catch в TS.

Отказоустойчивость OCR: Контролировать механизм ретраев (attempts_left) и предотвращение блокировки очереди «битыми» файлами.

Состояние гонки (Race Conditions): Использование токенов (например, noteLoadToken) для отмены устаревших обновлений при быстрой смене заметок.

5. Security (Безопасность)
IPC Boundaries: Строгое соблюдение границ IPC; фронтенд не должен иметь доступа к произвольным файлам вне разрешенных директорий data/ и settings/.

Криптография: Проверка корректности реализации AES-GCM через WebCrypto и отсутствие хранения паролей в открытом виде.

6. Performance (Производительность)
Debouncing: Обязательное использование задержек для «тяжелых» операций: 1000 мс для автосохранения и 200 мс для записи настроек.

Эффективность поиска: Все запросы к тексту должны проходить через FTS5-индексы (notes_fts, ocr_fts), избегая полных сканов таблиц LIKE %query%.
